1、SerialGC 最早的gc算法，yong区采用标记复制算法，old区采用标记-清除-整理算法，
    由于是串行的，任何一个区发生gc，都会引起整体的暂停， 单线程作业，不能充分利用现在
    多核cpu，暂停时间长，容易卡顿；
2、ParallelGC 并行GC，yong区采用标记复制算法，old区采用标记-清除-整理算法，
   可以指定gc线程数，对于多核cpu的利用更加充分，由于是多线程运行，gc时间更短

3、CMSGC 也是并行的，yong区采用标记复制算法，old区采用标记清除算法，在old区的处理，采用list来进行整理
    内存空间，去掉了单独的整理过程，降低了old区的gc时间，不会有明显的卡顿
    对于gc的处理方法：
    a、初始标记（STW暂停）；
    b、并发标记；
    c、并发预处理；
    d、最终标记（STW暂停）；
    e、并发清除；
    f、并发重置。

4、G1GC 不在区分yong区、old区，将堆划分为多个小区，默认为2048个，根据需要每个小区可以进行变动，eden、sur、old区。
    进行gc回收时，不会暂停整个堆，只暂停需要回收的小块即可，垃圾最多的块将会被优先回收，g1gc会不断的调整执行策略，尽量达到
    设置的gc回收时间。
    g1有可能会出现退化为SerialGC
    a、当g1在回收垃圾之前，old区被迅速填满；
    b、没有足够的空间供存活对象晋升到old；
    c、有大对象，但单个区间过小，无法进行存放

